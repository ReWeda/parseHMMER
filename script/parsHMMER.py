import json
import copy

class parsHMMER:

    # As of Feb 2019, this class is written to parse output generated by
    # HMMER v3.2.1 - command hmmscan
    # Written for python3; Compatibility with previous version must be tested
    # Output parser for other commands from the HMMER suite will be implemented in future

    def __init__(self, file_):
        
        # Store the path of the output generated by HMMER
        self.container = self.__read_output__(file_)
        self.__main_header = '# hmmscan :: search sequence(s) against a profile database'
        self.__domt_header = '#  '  # Find a more precise way to define domtblout file; for now that's good
        self.results = {}

    def __check_input__(self):
        # Check type of input. Right now, quite limited
        if self.container[0] == self.__main_header :
            return True
        elif self.container[0].startswith(self.__domt_header):
            return False
        else:
            raise IOError("Provided File doesn't appear to be generated by HMMER")

    def parse(self) :
        if self.__check_input__():
            return self.__main_parser__()
        else:
            return self.__domt_parser__()

    def __main_parser__(self):
        # Method to parse the main output 
        # Initialize the dictionary that will store the results

        query_line = self.container[12].split(':',1)
        query = query_line[1].strip().split()
        # Split is applied because the length of the query follows its name
        query_length = query[1][3:-1]
        query = query[0]

        description_line = self.container[13].split(':',1)
        description = description_line[1].strip()

        dash_line = self.container[17]
        idxs = [ x+1 for x in range(len(dash_line)-1) if dash_line[x+1]=='-' and dash_line[x] != '-']
        
        for x in range(18, len(self.container)):
            line = self.container[x]
            if not line:
                break
                # When we face an empty line we have parsed the summary section
            elif line.strip() == '------ inclusion threshold ------':
                # Just pass over this possible line that divide "good" match from "bad" one included given threshold
                pass
            else:
                fields = []
                fields.append(
                    line[:idxs[1]].strip()
                )
                for y in range(2, len(idxs)):
                    fields.append(
                        line[idxs[y-1]:idxs[y]].strip()
                    )
                fields.append(
                    line[idxs[-1]:].strip()
                )
                evalue_fs, score_fs, bias_fs, evalue_b1d, score_b1d, bias_b1d, exp_dom, n_dom, model_dom, descr = fields
                self.results[model_dom] = {
                    'target_accession'      : '-',
                    'query_name'            : query,
                    'query_description'     : description,
                    'query_length'          : int(query_length),
                    'full_sequence' : {
                        'evalue'            : float(evalue_fs),
                        'score'             : float(score_fs),
                        'bias'              : float(bias_fs)
                    },
                    'description'           : descr,
                    'this_domain'           : {}
                }
        # Check for the status of self.results
        if not self.results :
            return self.results
            # If the dictionary is empty, not matches have been found
        
        # Get indexes of match lines
        matches_line = [ x for x in range(18, len(self.container)) if self.container[x].startswith('>>') ]
        alignment_starting_line = [ x for x in range(18, len(self.container)) if self.container[x].strip().startswith('Alignments for each domain:') ]
        for x in range(len(matches_line)):
            start = matches_line[x]
            align = alignment_starting_line[x]
            if not x == len(matches_line)-1:
                end = matches_line[x+1]
            else:
                end = len(self.container) - 1
            target_name = self.container[start][2:].strip()
            dash_line = self.container[start+2]
            # To retrieve data from the summary we have to collect both start and end dash index for each field
            # cause element in the middle won't allow us to properly strip fields
            idxs_start = [ w+1 for w in range(len(dash_line)-1) if dash_line[w+1]=='-' and dash_line[w] != '-']
            idxs_end = [ w for w in range(len(dash_line)-1) if dash_line[w]=='-' and dash_line[w+1] != '-']
            # idxs_end is always 1 element shorter
            for y in range(start+3, align):
                # Iterate lines for a match.
                line = self.container[y]
                if line:
                    fields = []
                    for z in range(0,len(idxs_end)):
                        iA = idxs_start[z]
                        iB = idxs_end[z]+1
                        fields.append(
                            line[iA:iB].strip()
                        )
                    fields.append(
                        line[idxs_start[-1]:].strip()
                    )
                    n_td, score, bias, cevalue, ievalue, hmmfrom, hmmto, alifrom, alito, envfrom, envto, acc = fields
                    if not self.results[target_name]['this_domain'].get(int(n_td)):
                        self.results[target_name]['this_domain'][int(n_td)] = {
                                'c_evalue'      : float(cevalue),
                                'i_evalue'      : float(ievalue),
                                'score'         : float(score),
                                'bias'          : float(bias),
                                'hmm_coord'     : (int(hmmfrom),int(hmmto)),
                                'ali_coord'     : (int(alifrom), int(alito)),
                                'env_coord'     : (int(envfrom),int(envto)),
                                'accuracy'      : float(acc)
                            }
            header_domain_idxs = [w for w in range(align, end) if self.container[w].strip().startswith('==')]
            for y in range(0,len(header_domain_idxs)):
                # Iterate between two domain alignment fields
                iA = header_domain_idxs[y]
                if y == len(header_domain_idxs)-1 :
                    # if we are dealing with the last domain alignment section, we want to iterate up to end
                    # of the target section
                    iB = end
                else:
                    iB = header_domain_idxs[y+1]
                line_splitted = self.container[iA].strip().split()
                n_td = int(line_splitted[2])

                first_aln_line = [w for w in range(iA,iB) if self.container[w].strip().startswith(target_name)]
                # Iterate alignment lines section per domain
                target_aln = ''
                query_aln = ''
                middle_score = ''
                bottom_score = ''
                for z in range(0,len(first_aln_line)):
                    # Find range that include the effective alignment.
                    # Check for the spot with digit, space, char
                    aln_idx = first_aln_line[z]
                    line = self.container[aln_idx]
                    for i in range(1,len(line)):
                        if line[i]==' ' and line[i-1].isdigit() and not line[i+1].isdigit() and line[i+1] != ' ':
                            aln_start = i+1
                            break
                    for i in range(aln_start, len(line)):
                        if line[i]==' ':
                            aln_stop = i
                            break
                    target_aln += self.container[aln_idx][aln_start:aln_stop]
                    query_aln += self.container[aln_idx+1][aln_start:aln_stop]
                    middle_score += self.container[aln_idx+2][aln_start:aln_stop]
                    bottom_score += self.container[aln_idx+3][aln_start:aln_stop]
                self.results[target_name]['this_domain'][int(n_td)]['target_alignment'] = target_aln
                self.results[target_name]['this_domain'][int(n_td)]['query_alignment'] = query_aln
                self.results[target_name]['this_domain'][int(n_td)]['score1_alignment'] = middle_score
                self.results[target_name]['this_domain'][int(n_td)]['score2_alignment'] = bottom_score
        return self.results

    def __domt_parser__(self):
        # Method to parse the output generated by the flag --domtblout

        # We can't rely on splitting the lines containing matches
        # because some field could be large and merge with the previous one.
        # We can't set specific ranges for fields in the line containing matches
        # because they're usually fixed, but due to possible larger fields, they
        # can change. We have to extract fields length in the line 
        # before matches' lines (idx.)

        # 11th March 2019
        # Observed that the last version of HMMER doesn't behave as previous ones.
        # Larger field just steal space from the following field allowing line separation

        # Not required anymore
        # spacer_line = self.container[2]
        # idxs = [ x+1 for x in range(len(spacer_line)-1) if spacer_line[x]=='-' and spacer_line[x+1] != '-']
        # line sample : #------- -----
        # I'm saving indexes of white space  

        for x in range(3, len(self.container)):
            line = self.container[x]
            if not line.startswith('#') :
                # fields = []
                # fields.append(
                #     line[:idxs[0]].strip()
                # )
                # for y in range(1,len(idxs)):
                #     fields.append(
                #         line[idxs[y-1]+1:idxs[y]].strip()
                #     )
                # fields.append(
                #     line[idxs[-1]+1:].strip()
                # )
                fields = line.split()
                target_name, accessionT, tlen, query_name, accessionQ, qlen, evalue_fs, score_fs, bias_fs, n_td, of_td, cevalue_td, ievalue_td, score_td, bias_td, hmmcoord_from, hmmcoord_to, alicoord_from, alicoord_to, envcoord_from, envcoord_to, acc, description = [x.strip() for x in fields]
                if not self.results.get(target_name):
                    self.results[target_name] = {
                        'target_accession'      : accessionT,
                        'target_length'         : int(tlen),
                        'query_name'            : query_name,
                        'query_description'     : accessionQ,
                        'query_length'          : int(qlen),
                        'full_sequence' : {
                            'evalue'            : float(evalue_fs),
                            'score'             : float(score_fs),
                            'bias'              : float(bias_fs)
                        },
                        'this_domain' : {
                            int(n_td) : {
                                'c_evalue'      : float(cevalue_td),
                                'i_evalue'      : float(ievalue_td),
                                'score'         : float(score_td),
                                'bias'          : float(bias_td),
                                'hmm_coord'     : (int(hmmcoord_from),int(hmmcoord_to)),
                                'ali_coord'     : (int(alicoord_from), int(alicoord_to)),
                                'env_coord'     : (int(envcoord_from),int(envcoord_to)),
                                'accuracy'      : float(acc)
                            }
                        },
                        'description'           : description    
                    }
                else:
                    # Just add datas for the second match on an already matched target
                    self.results[target_name]['this_domain'][int(n_td)] = {
                        'c_evalue'      : float(cevalue_td),
                        'i_evalue'      : float(ievalue_td),
                        'score'         : float(score_td),
                        'bias'          : float(bias_td),
                        'hmm_coord'     : (int(hmmcoord_from),int(hmmcoord_to)),
                        'ali_coord'     : (int(alicoord_from), int(alicoord_to)),
                        'env_coord'     : (int(envcoord_from),int(envcoord_to)),
                        'accuracy'      : float(acc)
                    }
            else:
                break
        return self.results
    
    def printHMMER(self, idnt=4):
        print (json.dumps(self.results, indent=idnt))

    def best(self, verbose=False, top=1):
        if self.results :
            return self.__find_best__(verbose, top)
        else:
            raise ValueError("Please, run the parse method before. If it has been done, HMMER didn't found matches.")

    def __find_best__(self, verbose, top):
        slave_dictionary = copy.deepcopy(self.results)
        best_match = []
        i = 0
        while i < top :
            max_t = float("inf")
            max_d = float("inf")
            for target in slave_dictionary.keys():
                if slave_dictionary[target]['full_sequence']['evalue'] <= max_t :
                    for domain in slave_dictionary[target]["this_domain"].keys():
                        if slave_dictionary[target]["this_domain"][domain]['i_evalue'] < max_d :
                            best_domain = domain
                            best_target = target
                            max_t = slave_dictionary[target]['full_sequence']['evalue']
                            max_d = slave_dictionary[target]["this_domain"][domain]['i_evalue']
            if verbose :
                best_match.append(
                    (
                        best_target,
                        slave_dictionary[best_target]["target_accession"],
                        slave_dictionary[best_target]["description"],
                        slave_dictionary[best_target]['full_sequence']['evalue'],
                        slave_dictionary[best_target]['full_sequence']['score'],
                        slave_dictionary[best_target]['full_sequence']['bias'],
                        domain,
                        len(slave_dictionary[best_target]["this_domain"].keys()),
                        slave_dictionary[best_target]["this_domain"][best_domain]['c_evalue'],
                        slave_dictionary[best_target]["this_domain"][best_domain]['i_evalue'],
                        slave_dictionary[best_target]["this_domain"][best_domain]['score'],
                        slave_dictionary[best_target]["this_domain"][best_domain]['bias'],
                        slave_dictionary[best_target]["this_domain"][best_domain]['hmm_coord'],
                        slave_dictionary[best_target]["this_domain"][best_domain]['ali_coord'],
                        slave_dictionary[best_target]["this_domain"][best_domain]['env_coord'],
                        slave_dictionary[best_target]["this_domain"][best_domain]['accuracy']
                    )
                )
            else:
                best_match.append(
                    (
                        best_target,
                        slave_dictionary[best_target]['full_sequence']['score'],
                        slave_dictionary[best_target]['full_sequence']['evalue'],
                        domain,
                        len(slave_dictionary[best_target]["this_domain"].keys()),
                        slave_dictionary[best_target]["this_domain"][best_domain]['score'],
                        slave_dictionary[best_target]["this_domain"][best_domain]['i_evalue'],
                        slave_dictionary[best_target]["this_domain"][best_domain]['hmm_coord'],
                        slave_dictionary[best_target]["this_domain"][best_domain]['ali_coord'],
                        slave_dictionary[best_target]["this_domain"][best_domain]['accuracy']
                    )
                )
            # User asked for a number of best match higher than the total number of available matches
            if not slave_dictionary :
                break   # Exit the While loop
            slave_dictionary[best_target]['this_domain'].pop(best_domain, None)
            if not slave_dictionary[best_target]['this_domain'] :
                # If we ended up removing all the domains for that target, pop the target too
                slave_dictionary.pop(best_target, None)
            i += 1
        return best_match

    @staticmethod
    def writeHMMER(path, content, label_list=[]):
        # Check if an array of dictionary from this class 
        # have been passed as argument or not
        # Only a dictionary or an array of dictionary can be passed
        # Check if labels are provided
        # Check if enough labels have been provided
        if type(content) == dict :
            d = content
            if not label_list:
                label_list = ['HMMER_output_1']
            else:
                if not len(label_list) == 1 :
                    print ("Number of provided Label doesn't match the number of dictionary. Labels are set back to the standard format.")
                    label_list = ['HMMER_output_1']

            is_validated = parsHMMER.__check_dictionary_structure__(content)
            if not is_validated[0] :
                # Bad structure for the dictionary
                if is_validated[-1] == 'key_error' :
                    raise KeyError("Bad dictionary Structure. Missing key '{}' in target {} ".format(is_validated[2], is_validated[1]))
                else:
                    if len(is_validated) == 6:
                        raise TypeError("Bad dictionary Structure. Wrong variable type in key '{}' for model {} in sub-key {} in target {} ".format(is_validated[2], is_validated[1], is_validated[3], is_validated[4]))
                    else:
                        raise TypeError("Bad dictionary Structure. Wrong variable type in key '{}' for target {} ".format(is_validated[2], is_validated[1]))
            else:
                with open(path, 'w') as file_ :
                    file_.write(','.join([
                        'parsed_output',
                        'query',
                        'query_descr',
                        'query_len',
                        'target',
                        'target_descr',
                        'evalue',
                        'score',
                        'bias',
                        'model',
                        'c_evalue',
                        'i_evalue',
                        'model_score',
                        'model_bias',
                        'hmm_coord_s',
                        'hmm_coord_e',
                        'ali_coord_s',
                        'ali_coord_e',
                        'env_coord_s',
                        'env_coord_e',
                        'accuracy'
                    ]) + '\n')
                    for target_name in d.keys():
                        for domain in d[target_name]['this_domain'].keys():
                            file_.write(','.join([
                                label_list[0],
                                d[target_name]['query_name'],
                                d[target_name]['query_description'],
                                str(d[target_name]['query_length']),
                                target_name,
                                d[target_name]['target_accession'],
                                str(d[target_name]['full_sequence']['evalue']),
                                str(d[target_name]['full_sequence']['score']),
                                str(d[target_name]['full_sequence']['bias']),
                                str(domain),
                                str(d[target_name]['this_domain'][domain]['c_evalue']),
                                str(d[target_name]['this_domain'][domain]['i_evalue']),
                                str(d[target_name]['this_domain'][domain]['score']),
                                str(d[target_name]['this_domain'][domain]['bias']),
                                str(d[target_name]['this_domain'][domain]['hmm_coord'][0]),
                                str(d[target_name]['this_domain'][domain]['hmm_coord'][1]),
                                str(d[target_name]['this_domain'][domain]['ali_coord'][0]),
                                str(d[target_name]['this_domain'][domain]['ali_coord'][1]),
                                str(d[target_name]['this_domain'][domain]['env_coord'][0]),
                                str(d[target_name]['this_domain'][domain]['env_coord'][1]),
                                str(d[target_name]['this_domain'][domain]['accuracy']),
                                ]) + '\n')
        elif type(content) == list :
            if not label_list:
                label_list = ['HMMER_output_{}'.format(i+1) for i in range(len(content))]
            else:
                if not len(label_list) == len(content) :
                    print ("Number of provided Label doesn't match the number of dictionary. Labels are set back to the standard format.")
                    label_list = ['HMMER_output_{}'.format(i+1) for i in range(len(content))]
            i = 0
            for d in content :
                is_validated = parsHMMER.__check_dictionary_structure__(d)
                if not is_validated[0] :
                    # Bad structure for the dictionary
                    if is_validated[-1] == 'key_error' :
                        raise KeyError("Bad dictionary Structure on index {}. Missing key '{}' in target {} ".format(i, is_validated[2], is_validated[1]))
                    else:
                        if len(is_validated) == 6:
                            raise TypeError("Bad dictionary Structure on index {}. Wrong variable type in key '{}' for model {} in sub-key {} in target {} ".format(i, is_validated[2], is_validated[1], is_validated[3], is_validated[4]))
                        else:
                            raise TypeError("Bad dictionary Structure on index {}. Wrong variable type in key '{}' for target {} ".format(i, is_validated[2], is_validated[1]))
                i += 1
            i = 0
            with open(path, 'w') as file_:
                file_.write(','.join([
                        'parsed_output',
                        'query',
                        'query_descr',
                        'query_len',
                        'target',
                        'target_descr',
                        'evalue',
                        'score',
                        'bias',
                        'model',
                        'c_evalue',
                        'i_evalue',
                        'model_score',
                        'model_bias',
                        'hmm_coord_s',
                        'hmm_coord_e',
                        'ali_coord_s',
                        'ali_coord_e',
                        'env_coord_s',
                        'env_coord_e',
                        'accuracy'
                    ]) + '\n')
                for d in content :
                    for target_name in d.keys():
                        for domain in d[target_name]['this_domain'].keys():
                            file_.write(','.join([
                                label_list[i],
                                d[target_name]['query_name'],
                                d[target_name]['query_description'],
                                str(d[target_name]['query_length']),
                                target_name,
                                d[target_name]['target_accession'],
                                str(d[target_name]['full_sequence']['evalue']),
                                str(d[target_name]['full_sequence']['score']),
                                str(d[target_name]['full_sequence']['bias']),
                                str(domain),
                                str(d[target_name]['this_domain'][domain]['c_evalue']),
                                str(d[target_name]['this_domain'][domain]['i_evalue']),
                                str(d[target_name]['this_domain'][domain]['score']),
                                str(d[target_name]['this_domain'][domain]['bias']),
                                str(d[target_name]['this_domain'][domain]['hmm_coord'][0]),
                                str(d[target_name]['this_domain'][domain]['hmm_coord'][1]),
                                str(d[target_name]['this_domain'][domain]['ali_coord'][0]),
                                str(d[target_name]['this_domain'][domain]['ali_coord'][1]),
                                str(d[target_name]['this_domain'][domain]['env_coord'][0]),
                                str(d[target_name]['this_domain'][domain]['env_coord'][1]),
                                str(d[target_name]['this_domain'][domain]['accuracy']),
                                ]) + '\n')
                    i += 1
        else:
            wrong_type = type(content)
            raise TypeError("Variable passed to writing function is of a wrong type ({}). writeHMMER() only accepts a dictionary returned from an instance of parsHMMER class or an array of them.".format(wrong_type))

    @staticmethod
    def __check_dictionary_structure__(d):
        for target_name in d.keys():
            # Check if all the L1 keys are present w/ the correct variable type
            first_layer_keys = ['target_accession', 'query_name', 'query_description', 'description']
            for k in first_layer_keys:
                if not k in d[target_name] :
                    return (False, target_name, k, 'key_error')
                else:
                    if not type(d[target_name][k]) == str :
                        return (False, target_name, k, 'type_error')
            if not 'query_length' in d[target_name]:
                return (False, target_name, 'query_length', 'key_error')
            else:
                if not type(d[target_name]['query_length']) == int :
                    return (False, target_name, 'query_length', 'type_error')
            for k in ['full_sequence', 'this_domain']:
                if not k in d[target_name]:
                    return (False, target_name, k, 'key_error')

            # Check if all the L2 keys are present w/ the correct variable type
            full_seq_keys = ['evalue', 'score', 'bias']
            for k in full_seq_keys:
                if not k in d[target_name]['full_sequence'] :
                    return (False, target_name, k, 'key_error')
                else:
                    if not type(d[target_name]['full_sequence'][k]) == float :
                        return (False, target_name, k, 'type_error')

            # Check This domain layer
            this_domain_keys_float = ['c_evalue', 'i_evalue', 'score', 'bias', 'accuracy']
            this_domain_keys_tuple = ['hmm_coord', 'ali_coord', 'env_coord']
            for domain in d[target_name]['this_domain'].keys():
                for k in this_domain_keys_float:
                    if not k in d[target_name]['this_domain'][domain]:
                        return (False, target_name, 'this_domain', 'key_error')
                    else:
                        if not type(d[target_name]['this_domain'][domain][k]) == float :
                            return (False, target_name, 'this_domain', domain, k, 'type_error')
                for k in this_domain_keys_tuple:
                    if not k in d[target_name]['this_domain'][domain]:
                        return (False, target_name, 'this_domain', 'key_error')
                    else:
                        if not type(d[target_name]['this_domain'][domain][k]) == tuple :
                            return (False, target_name, 'this_domain', domain, k, 'type_error')
        return (True,)
    
    @staticmethod
    def __read_output__(file_):
        with open(file_, 'r') as f_:
            container = f_.readlines()
        return [ line.rstrip() for line in container]