import json

class parsHMMER:

    # As of Feb 2019, this class is written to parse output generated by
    # HMMER v3.2.1 - command hmmscan
    # Written for python3; Compatibility with previous version must be tested
    # Output parser for other commands from the HMMER suite will be implemented in future

    def __init__(self, file_):
        
        # Store the path of the output generated by HMMER
        self.container = self.__read_output__(file_)
        self.__main_header = '# hmmscan :: search sequence(s) against a profile database'
        self.__domt_header = '#  '  # Find a more precise way to define domtblout file; for now that's good
        self.results = {}


    @staticmethod
    def __read_output__(file_):
        with open(file_, 'r') as f_:
            container = f_.readlines()
        return [ line.rstrip() for line in container]

    def __check_input__(self):
        if self.container[0] == self.__main_header :
            return True
        elif self.container[0].startswith(self.__domt_header):
            return False
        else:
            raise IOError("Provided File doesn't appear to be generated by HMMER")

    def parse(self) :
        if self.__check_input__():
            return self.__main_parser__()
        else:
            return self.__domt_parser__()

    def __main_parser__(self):
        # Method to parse the main output 
        # Initialize the dictionary that will store the results

        query_line = self.container[12].split(':',1)
        query = query_line[1].strip().split()
        # Split is applied because the length of the query follows its name
        length = query[1][3:-1]
        query = query[0]

        description_line = self.container[13].split(':',1)
        description = description_line[1].strip()

        dash_line = self.container[17]
        idxs = [ x+1 for x in range(len(dash_line)-1) if dash_line[x+1]=='-' and dash_line[x] != '-']
        
        for x in range(18, len(self.container)):
            line = self.container[x]
            if not line:
                break
                # When we face an empty line we have parsed the summary section
            else:
                fields = []
                fields.append(
                    line[:idxs[1]].strip()
                )
                for y in range(2, len(idxs)):
                    fields.append(
                        line[idxs[y-1]:idxs[y]].strip()
                    )
                fields.append(
                    line[idxs[-1]:].strip()
                )
                evalue_fs, score_fs, bias_fs, evalue_b1d, score_b1d, bias_b1d, exp_dom, n_dom, model_dom, descr = fields
                self.results[model_dom] = {
                    'target_accession'      : '-',
                    'query_name'            : query,
                    'query_description'     : description,
                    'target_length'         : int(length),
                    'full_sequence' : {
                        'evalue'            : float(evalue_fs),
                        'score'             : float(score_fs),
                        'bias'              : float(bias_fs)
                    },
                    'description'           : descr,
                    'this_domain'           : {}
                }
        # Check for the status of self.results
        if not self.results :
            return self.results
            # If the dictionary is empty, not matches have been found
        
        # Get indexes of match lines
        matches_line = [ x for x in range(18, len(self.container)) if self.container[x].startswith('>>') ]
        alignment_starting_line = [ x for x in range(18, len(self.container)) if self.container[x].strip().startswith('Alignments for each domain:') ]
        for x in range(len(matches_line)):
            start = matches_line[x]
            align = alignment_starting_line[x]
            if not x == len(matches_line)-1:
                end = matches_line[x+1]
            else:
                end = len(self.container) - 1
            target_name = self.container[start][2:].strip()
            dash_line = self.container[start+2]
            # To retrieve data from the summary we have to collect both start and end dash index for each field
            # cause element in the middle won't allow us to properly strip fields
            idxs_start = [ w+1 for w in range(len(dash_line)-1) if dash_line[w+1]=='-' and dash_line[w] != '-']
            idxs_end = [ w for w in range(len(dash_line)-1) if dash_line[w]=='-' and dash_line[w+1] != '-']
            # idxs_end is always 1 element shorter
            for y in range(start+3, align):
                # Iterate lines for a match.
                line = self.container[y]
                if line:
                    fields = []
                    for z in range(0,len(idxs_end)):
                        iA = idxs_start[z]
                        iB = idxs_end[z]+1
                        fields.append(
                            line[iA:iB].strip()
                        )
                    fields.append(
                        line[idxs_start[-1]:].strip()
                    )
                    n_td, score, bias, cevalue, ievalue, hmmfrom, hmmto, alifrom, alito, envfrom, envto, acc = fields
                    if not self.results[target_name]['this_domain'].get(int(n_td)):
                        self.results[target_name]['this_domain'][int(n_td)] = {
                                'c_evalue'      : float(cevalue),
                                'i_evalue'      : float(ievalue),
                                'score'         : float(score),
                                'bias'          : float(bias),
                                'hmm_coord'     : (int(hmmfrom),int(hmmto)),
                                'ali_coord'     : (int(alifrom), int(alito)),
                                'env_coord'     : (int(envfrom),int(envto)),
                                'accuracy'      : float(acc)
                            }
            header_domain_idxs = [w for w in range(align, end) if self.container[w].strip().startswith('==')]
            for y in range(0,len(header_domain_idxs)):
                # Iterate between two domain alignment fields
                iA = header_domain_idxs[y]
                if y == len(header_domain_idxs)-1 :
                    # if we are dealing with the last domain alignment section, we want to iterate up to end
                    # of the target section
                    iB = end
                else:
                    iB = header_domain_idxs[y+1]
                line_splitted = self.container[iA].strip().split()
                n_td = int(line_splitted[2])

                first_aln_line = [w for w in range(iA,iB) if self.container[w].strip().startswith(target_name)]
                # Iterate alignment lines section per domain
                target_aln = ''
                query_aln = ''
                middle_score = ''
                bottom_score = ''
                for z in range(0,len(first_aln_line)):
                    # Find range that include the effective alignment.
                    # Check for the spot with digit, space, char
                    aln_idx = first_aln_line[z]
                    line = self.container[aln_idx]
                    for i in range(1,len(line)):
                        if line[i]==' ' and line[i-1].isdigit() and not line[i+1].isdigit() and line[i+1] != ' ':
                            aln_start = i+1
                            break
                    for i in range(aln_start, len(line)):
                        if line[i]==' ':
                            aln_stop = i
                            break
                    target_aln += self.container[aln_idx][aln_start:aln_stop]
                    query_aln += self.container[aln_idx+1][aln_start:aln_stop]
                    middle_score += self.container[aln_idx+2][aln_start:aln_stop]
                    bottom_score += self.container[aln_idx+3][aln_start:aln_stop]
                self.results[target_name]['this_domain'][int(n_td)]['target_alignment'] = target_aln
                self.results[target_name]['this_domain'][int(n_td)]['query_alignment'] = query_aln
                self.results[target_name]['this_domain'][int(n_td)]['score1_alignment'] = middle_score
                self.results[target_name]['this_domain'][int(n_td)]['score2_alignment'] = bottom_score
        return self.results




    def __domt_parser__(self):
        # Method to parse the output generated by the flag --domtblout

        # We can't rely on splitting the lines containing matches
        # because some field could be large and merge with the previous one.
        # We can't set specific ranges for fields in the line containing matches
        # because they're usually fixed, but due to possible larger fields, they
        # can change. We have to extract fields length in the line 
        # before matches' lines (idx.)

        spacer_line = self.container[2]
        idxs = [ x+1 for x in range(len(spacer_line)-1) if spacer_line[x]=='-' and spacer_line[x+1] != '-']
        # line sample : #------- -----
        # I'm saving indexes of white space  

        for x in range(3, len(self.container)):
            line = self.container[x]
            if not line.startswith('#') :
                fields = []
                fields.append(
                    line[:idxs[0]].strip()
                )
                for y in range(1,len(idxs)):
                    fields.append(
                        line[idxs[y-1]+1:idxs[y]].strip()
                    )
                fields.append(
                    line[idxs[-1]+1:].strip()
                )
                target_name, accessionT, tlen, query_name, accessionQ, qlen, evalue_fs, score_fs, bias_fs, n_td, of_td, cevalue_td, ievalue_td, score_td, bias_td, hmmcoord_from, hmmcoord_to, alicoord_from, alicoord_to, envcoord_from, envcoord_to, acc, description = fields
                if not self.results.get(target_name):
                    self.results[target_name] = {
                        'target_accession'      : accessionT,
                        'target_length'         : int(tlen),
                        'query_name'            : query_name,
                        'query_accession'       : accessionQ,
                        'query_length'          : int(qlen),
                        'full_sequence' : {
                            'evalue'            : float(evalue_fs),
                            'score'             : float(score_fs),
                            'bias'              : float(bias_fs)
                        },
                        'this_domain' : {
                            int(n_td) : {
                                'c_evalue'      : float(cevalue_td),
                                'i_evalue'      : float(ievalue_td),
                                'score'         : float(score_td),
                                'bias'          : float(bias_td),
                                'hmm_coord'     : (int(hmmcoord_from),int(hmmcoord_to)),
                                'ali_coord'     : (int(alicoord_from), int(alicoord_to)),
                                'env_coord'     : (int(envcoord_from),int(envcoord_to)),
                                'accuracy'      : float(acc)
                            }
                        },
                        'description'           : description    
                    }
                else:
                    # Just add datas for the second match on an already matched target
                    self.results[target_name]['this_domain'][int(n_td)] = {
                        'c_evalue'      : float(cevalue_td),
                        'i_evalue'      : float(ievalue_td),
                        'score'         : float(score_td),
                        'bias'          : float(bias_td),
                        'hmm_coord'     : (int(hmmcoord_from),int(hmmcoord_to)),
                        'ali_coord'     : (int(alicoord_from), int(alicoord_to)),
                        'env_coord'     : (int(envcoord_from),int(envcoord_to)),
                        'accuracy'      : float(acc)
                    }
            else:
                break
        return self.results
    
    def printHMMER(self, idnt=4):
        print (json.dumps(self.results, indent=idnt))

    def best(self, verbose=False):
        if self.results :
            return self.__find_best__(verbose)
        else:
            raise ValueError("Please, run the parse method before. If it has been done, HMMER didn't found matches.")

    def __find_best__(self, verbose):
        max_t = float("inf")
        max_d = float("inf")
        for target in self.results.keys():
            if self.results[target]['full_sequence']['evalue'] < max_t :
                max_t = self.results[target]['full_sequence']['evalue']
                for domain in self.results[target]["this_domain"].keys():
                    if self.results[target]["this_domain"][domain]['i_evalue'] < max_d :
                        max_d = self.results[target]["this_domain"][domain]['i_evalue']
                        if verbose :
                            self.bestMatch = (
                                target,
                                self.results[target]["target_accession"],
                                self.results[target]["target_length"],
                                self.results[target]["description"],
                                self.results[target]['full_sequence']['evalue'],
                                self.results[target]['full_sequence']['score'],
                                self.results[target]['full_sequence']['bias'],
                                domain,
                                len(self.results[target]["this_domain"].keys()),
                                self.results[target]["this_domain"][domain]['c_evalue'],
                                self.results[target]["this_domain"][domain]['i_evalue'],
                                self.results[target]["this_domain"][domain]['score'],
                                self.results[target]["this_domain"][domain]['bias'],
                                self.results[target]["this_domain"][domain]['hmm_coord'],
                                self.results[target]["this_domain"][domain]['ali_coord'],
                                self.results[target]["this_domain"][domain]['env_coord'],
                                self.results[target]["this_domain"][domain]['accuracy'],
                            )
                        else:
                            self.bestMatch = (
                                target,
                                self.results[target]["target_length"],
                                self.results[target]['full_sequence']['evalue'],
                                domain,
                                len(self.results[target]["this_domain"].keys()),
                                self.results[target]["this_domain"][domain]['i_evalue'],
                                self.results[target]["this_domain"][domain]['hmm_coord'],
                                self.results[target]["this_domain"][domain]['ali_coord'],
                                self.results[target]["this_domain"][domain]['accuracy'],
                            )
        return self.bestMatch